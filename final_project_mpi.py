# -*- coding: utf-8 -*-
"""final_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B1TikSrq0XeXJ0EvMzDXuQe4UqVFXsj7

Import google drive, download and convert soundfiles.
It has to be authorized to work.

---
"""



"""import dependencies, define helper functions:"""

# Commented out IPython magic to ensure Python compatibility.

import os
import numpy as np
import matplotlib.pyplot as plt
import librosa
from IPython.display import Audio
from magenta.models.nsynth import utils
from magenta.models.nsynth.wavenet import fastgen
from skimage.transform import resize
from mpi4py import MPI
from math import ceil, floor

FILENAMES = ['clarinet.wav', 'marbles.wav', 'piano.wav']
ENCODINGS_DIR = 'encodings/'
INPUT_DIR = 'input/'
OUTPUT_DIR = 'output/'
MODEL_DIR = 'wavenet-ckpt/model.ckpt-200000'


#variables for parallel programming
comm = MPI.COMM_WORLD
process_rank = comm.Get_rank()
process_size = comm.Get_size()


#do all the calculations with the first rank
if process_rank == 0:

    def timestretch(encodings, factor):
        min_encodings, max_encodings = encodings.min(), encodings.max()
        encodings_norm = (encodings - min_encodings) / (max_encodings - min_encodings)
        timestretches = []
        for encoding_i in encodings_norm:
            stretched = resize(encoding_i, (int(encoding_i.shape[0] * factor), encoding_i.shape[1]), mode='reflect')
            stretched = (stretched * (max_encodings - min_encodings)) + min_encodings
            timestretches.append(stretched)
        return np.array(timestretches)

    """Load soundfiles and saves encodings in List."""

    def encodeMultiple(filenames):
      audios = []
      encodings = []
      for filename in filenames:
        y, sr = librosa.load(INPUT_DIR + filename) #extract file length in samples
        audio = utils.load_audio(INPUT_DIR + filename, sample_length=len(y), sr=sr)
        audios.append(audio)
        sample_length = audio.shape[0]
        print('{} samples, {} seconds'.format(sample_length, sample_length / float(sr)))

        encoding = fastgen.encode(audio, MODEL_DIR, sample_length)
        encodings.append(encoding)
        np.save(ENCODINGS_DIR + filename + '.npy', encoding)
        print(f'encoding saved as {filename + ".npy"}')
      return encodings

    #encode files
    encodings = encodeMultiple(FILENAMES)


    """Time stretch to fit to a single duration:"""

    #this function calculates the longest encoding
    def longestEncoding(encodingList):
      lengths = [encoding[0].shape[0] for encoding in encodingList]
      return max(lengths)

    #Fits the rest to the  length of the longest
    def fitEncodings(encodingList):
      longest = longestEncoding(encodingList)
      for i, item in enumerate(encodings):
        if item.shape[1] < longest:
          encodingList[i] = timestretch(encodingList[i], longest/item.shape[1])
      return encodingList

    encodings_fitted = fitEncodings(encodings)

    """Make interpolations"""

    #makes a single encoding out of three different ones.
    #input a list encodings and a list of weights for each one.
    def encodeWeights(encodings, weightList):
      normedWeights = [i/sum(weightList) for i in weightList]
      return (encodings[0]*normedWeights[0] + encodings[1]*normedWeights[1] + encodings[2]*normedWeights[2])

    #example with equal weight
    enc_mix = encodeWeights(encodings_fitted, [3, 3, 3])

    '''
    #This is the interpolation with equal weight
    fig, axs = plt.subplots(4, 1, figsize=(10, 7))
    axs[0].plot(encodings[0][0]); 
    axs[0].set_title('Encoding 1')
    axs[1].plot(encodings[1][0]);
    axs[1].set_title('Encoding 2')
    axs[2].plot(encodings[2][0]);
    axs[2].set_title('Encoding 3')
    axs[3].plot(enc_mix[0]);
    axs[3].set_title('Average')

    enc_mix.shape
    '''

    """Save each interpolated encoding in npy files."""

    #create array of percentages of presence of each number in encodings

    levels = [0, 33, 66, 100]

    percentages = []
    individual_sounds_nums = set()

    for first in levels:
      for second in levels:
        for third in levels:
          values = (first, second, third)
          if values.count(0) < 3:
            percentages.append(values)
            individual_sounds_nums.add(tuple(values))

    individual_sounds_nums = sorted(individual_sounds_nums)

    #Create encodings of every element in the percentage array. Each point the resulting 3d matrix.
    def encodeMultiple(encodings, percentages_list):
      all_encodings = []
      coordinate = []
      for coordinates in percentages_list:
        result = [''.join(str(coordinate)) for coordinate in coordinates]
        coord_str = ''
        for num in result:
          coord_str += '_' + num
        interpolated_encoding = encodeWeights(encodings, list(coordinates))
        #save encodings in google drive
        np.save(ENCODINGS_DIR +'mix'+ coord_str + '.npy', interpolated_encoding[0])
        all_encodings.append(interpolated_encoding)
        coordinate.append(coord_str)

      #returns encoding and string for path
      return (np.array(all_encodings), np.array(coordinate))

      #this returns every individual encodings.
    #If you want every encoding (including repeated like (0, 50 50) (0, 100, 100)) use "percentages" instead of "indidivual_sounds_nums"
    all_encodings, percentages_str = encodeMultiple(encodings_fitted, percentages)


    #slice whole array of encodings so that each procees only decodes a fraction of the sounds
    length_pieces = ceil(len(all_encodings)/process_size)
    sl = slice(length_pieces) #slice array every lenght_pieces elements
    local_encodings = all_encodings[sl]
    local_perc_str =  percentages_str[sl]

    print(percentages_str)

    print(local_perc_str)
    for process_id in range(1, process_size):
        encodings_slice = all_encodings[process_id*length_pieces:][sl]
        percentages_slice = percentages_str[process_id*length_pieces:][sl]
        comm.send((encodings_slice, percentages_slice), dest=process_id)

    for encoding, percentage_str in zip(local_encodings, local_perc_str):
      fastgen.synthesize(encoding, checkpoint_path= MODEL_DIR,
                         save_paths=[OUTPUT_DIR + 'gen_mix' + percentage_str+ '.wav'])

else:
    encodings_slice, percentages_slice = comm.recv(source=0)
    print(process_rank)
    print(percentages_slice)

    for encoding, percentage_str in zip(encodings_slice, percentages_slice):
      fastgen.synthesize(encoding, checkpoint_path= MODEL_DIR,
                         save_paths=[OUTPUT_DIR + 'gen_mix' + percentage_str+ '.wav'])

MPI.Finalize
